% ==============================================================================
%                                    DVG303
%                  Objektorienterad design och programmering
%                                Laboration #2
%
% Author:   Jonas Sjöberg
%           Högskolan i Gävle
%           tel12jsg@student.hig.se
%           https://github.com/jonasjberg
%
% License:  Creative Commons Attribution-NonCommercial-ShareAlike 4.0
%           International.  See LICENSE.md for full licensing information.
% ==============================================================================

\section{Uppgift 2}\label{sec:uppg2}

\subsection{}\label{sec:uppg2a}
\subsubsection*{Frågeställning}
Ändra modellklasserna från laboration 1 så att de implementerar interfacen
ifall det passar.

\subsubsection*{Lösning}
Den enklaste figur-klassen \texttt{Figure} implementerar interfacet
\texttt{Movable}.  Underklasserna \texttt{Point}, \texttt{Circle} och
\texttt{Ellipse} implementerar sedan \texttt{Scalable} och \texttt{Rotatable}
beroende på vad som är lämpligt för respektive klass.

\begin{itemize}
\item \texttt{Point} behöver varken roteras eller skalas och implementerar
      indirekt \texttt{Movable} genom superklassen \texttt{Figure}.
\item \texttt{Circle} kan skalas men behöver inte roteras och implementerar
      följdaktligen \texttt{Movable} (ärvs från superklassen) och 
      \texttt{Scalable}.
\item \texttt{Ellipse} kan både skalas och roteras och implementerar
      \texttt{Movable} (ärvs från superklassen), \texttt{Rotatable} och 
      \texttt{Scalable}.
\end{itemize}

Jag inser nu att arvshierarkin är onödigt komplex, det finns ingen större vits
med att ha två separata arvsträd av figurtyper, \texttt{SimpleFigure} och
\texttt{Figure}. Men vid det här laget finns inte tid för någon
omstrukturering.


\subsection{}\label{sec:uppg2b}
\subsubsection*{Frågeställning}
Varje klass i dataskiktet som kan instansieras ska kompletteras med en metod
toString (för mer information se PDF-filen Chapter3.pdf, ’Item 10: Always
override toString’).

\subsubsection*{Lösning}
Se bifogad källkod. Lösningen använder \texttt{StringBuilder} för att
konkatenera resultatet från superklassens \texttt{toString}-metod med klassens
egna data.


\subsection{}\label{sec:uppg2c}
\subsubsection*{Frågeställning}
Diskutera: Varför används typer som \texttt{List<FigureType>} i FigureHandler?
Kan man inte använda bara List? Eller en array?


\subsubsection*{Lösning}
Användningen av en \texttt{List} framför en vanlig array motiveras med att en
array inte kan ändra storlek dynamiskt. Storleken definieras vid skapande av
arrayen och är därefter fixerad. En \texttt{List} har flera användbara
funktioner som saknas för arrays. Genom att skriva något i stil med
\texttt{List<Figure>} specifieras vilken typ av objekt listan kan innehålla.
Det fungerar som en slags felkontroll där kompilatorn ger varningar om ett
inkompatibelt objekt stoppas in.


